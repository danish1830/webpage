---
title: 'A N2PZDO2 model'
author: ' Marilaure Gr√©goire'
date: "CE2COAST Winter School February 2023"
output:
  pdf_document:
    toc: yes
  slidy_presentation:
    css: tp_slidy.css
    font-adjustment: 0
    highlight: default
    mathjax: local
    pandoc_args: -V slidy-url=myslidy
    self_contained: no
  beamer_presentation:
    highlight: default
  html_document:
    code_folding: hide
    mathjax: local
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
---

# Introduction
This is a Fasham type model involving inorganic nitrogen, phytoplankton, zooplankton, detritus and dissolved oxygen. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading Packages  
Several packages are needed to run the model; they are the package deSolve (Soetaert et al., 2010), marelac (Soetaert and Petzoldt, 2017), diagram and FME (Soetaert and Petzoldt, 2016).

```{r}
require(deSolve)  # The package with the solution methods
require(marelac)  # chemical properties
require(diagram)  # Plotting foodweb
require(FME)      # Sensitivity Analysis
```
# Model description
## The model Parameters
Parameters are constants that we use in the model equations. 

In the following R-code, the model parameters are combined in a vector. 

```{r}
Parms <- c(
  depth         = 5,        # [m ] depth of the bay
  arrheniusCt   = 1.07,     #   -  Temperature Dependency of Process rates 
 
  #Physical parameters                                                
  salinity                    = 34,     #           - 
  TempTrend                 =0., #Temperature estimated trend
 
 #Phytoplankton
  maxUptake      = 1., # [/day] Maximum uptake rate 
  ksPAR          = 55., # [W/m2] half-saturation coefficient for light
  ksDIN          = 1.0, # [mmolN/m3] half-saturation coefficient for nutrient
  kd             = 0.1,     # /m   Light exinction coefficient
  ChlNratio     = 1, # mgChla/mmolN
  RespFrac       = 0.3, #Fraction of the uptake that is respired
  mortalityRatePHYTO =0.05, #Natural lysis of phytoplankton 
  
 #Zooplankton
  maxGrazing    = 1.0,  # [/day] Maximum Grazing rate
  ksGrazing     = 1.0, # [mmolN/m3] half-saturation coefficient for nutrient
  pFaeces       = 0.3,  # [-]
  excretionRate = 0.1, # [/day]
  mortalityRateZOO = 0.4, # [/(mmolN/m3)/day]
  
  #Reminaeralisation 
  mineralisationRate = 0.1, # [/day]
  ONratio =0.16, #molO2/molN, Oxygen to nitrogen ratio of organic matter
  
  #Mimic eutrophication by adding a flux of detritus and DIN
  DilRate=0.05, #Dilution rate /day
  DET_River=10., #Concentration of detritus in the rivers in mmolN/m3
  DIN_River=10. #Concentration of DIN in the rivers in mmolN/m3
)

```

## State variables

State variables are explicitly described in the model by differential equations. They need to be given a name and an initial value. All concentrations are expressed in mol C/m2.

```{r}
States <- c(DIN       = 2.5,   # mmolN/m3  initial concentration of dissolved inorganic nitrogen  
            PHYTO     = 0.05,   # mmolN/m3 initial phytoplankton biomass  
            ZOO       = 0.03,   # mmolNm3   initial zooplankton biomass 
            DET       = 0.5,    # mmolN/m3  initial detritus concentration
            DOX       = 240)  # mmolO2/m3   initial oxygen concentration
            
```

## forcing functions
Forcing functions are model components that influcence the dynamics of the system but that are not explicitly described in the model. Yet, they are important enough to be included in the model. They are imposed by observed data, which are in subdirectory ./Forcings/

The following forcings are used:

* fTemperature  , units= dgC  - air temperature  file=Temperature_DailyAveraged.txt
* fLight        , units= Wm-2   - Photosynthetically Activve Radiation file=SolarRadiation_DailyAveraged.txt
* fWind         , units= ms-1   - wind speed file=Wind_MeteoStation.txt

Here, temperature affects many process rates, the light is required for photosynthesis, and the wind determines the exchange of oxygen.

The following code reads those files and creates forcing functions that interpolate these data. When called with the appropriate time, these functions will return the forcing function value for that time point. The argument *rule = 2* ensures that extrapolation occurs beyond the data. 

```{r}
data.temperature <- read.table(file = "Forcings/Temperature_DailyAveraged.txt", skip=1, header=TRUE)  
data.light <- read.table(file = "Forcings/SolarRadiation_DailyAveraged.txt", 
                                 skip=1, header=TRUE)  
data.wind  <- read.table(file = "Forcings/Wind_MeteoStation.txt", skip=1, header=TRUE) 

ftemperature     <- approxfun(x = data.temperature[,2], y = data.temperature[,3], rule = 2)
flight           <- approxfun(x = data.light[,2], y = data.light[,3], rule = 2)
fwind            <- approxfun(x = data.wind[,2], y = data.wind[,3], rule = 2)

Day<-trunc(data.wind[,2])
Wind<-tapply(data.wind[,3],INDEX=Day,FUN=mean)
fwind<-approxfun(x=0:365,y=Wind,rule=2)

```


## observations
Finally, the realism of the model needs to be assessed by comparing it to observations. Observations are in subdirectory ./Data/

Oxygen observations from optodes are used:

* 'OxygenObs"  ,units= "mol/l"  - "Oxygen concentration from optode at 9m" ,file="Oxygen_DailyAveraged.txt"),

The following code reads this file and creates observations data files

```{r}
data.oxygen   <- read.table(file = "Data/Oxygen_DailyAveraged.txt", skip=1, header=TRUE)  

```

## The model function

In the model function (called *NPZDO2*), we define the model equations by describing the rate of change of the state variables. We also calculate some model variables, which are calculated as a function of the state variables. These variables are used for instance to compare the model to data, or to get information on the rates.

This function will be entered several times as R is solving the model. Each time it enters, it will have the actual time (t), the values of the state variables at that time (y), and the parameters (parms).

The first statement in this function (*with (as.list(c(arms,y))*) ensures that within the function, you can use the names of the parameters and state variables.


```{r }
NPZDO2 <- function(t, y, parms)
 {
 with(as.list(c(y, parms)),{

#=============================!
# Initialisation              !
#=============================!

# set forcing functions  
  Light       <- flight(t)           # determines photosynthesis
  Wind        <- fwind(t)            # modulates the air-sea exchange
  Temperature <- ftemperature(t) +TempTrend     # affects biological rates and air-sea exchange 
  Salinity<-salinity

# Photosynthesis depends on the light, light decreases with water depth, not all light is PAR
 
  PAR <- 0.5*Light *exp(-kd*(depth)) # 50% of light in par,   

#  All rates are expressed at 18 dg - Tempfac = the factor of increase with temperature
  Tempfac <- arrheniusCt ^ (Temperature-18.)
  
#=============================!
# The biological rates        !
#=============================!

# Rate expressions - all in units of [mmolN/m3/day]
    DINuptake <- Tempfac*maxUptake * PAR/(PAR+ksPAR) * DIN/(DIN+ksDIN)*PHYTO
    Grazing   <- Tempfac*maxGrazing* PHYTO/(PHYTO+ksGrazing)*ZOO
    Faeces    <- pFaeces * Grazing
    ZooGrowth <- (1-pFaeces) * Grazing
    Excretion <- Tempfac*excretionRate * ZOO
    MortalityZOO <- Tempfac*mortalityRateZOO * ZOO * ZOO
    MortalityPHYTO <- Tempfac*mortalityRatePHYTO * PHYTO
    Mineralisation <- Tempfac*mineralisationRate * DET
    
# Oxygen dynamics   
# Rate expressions - all in units of [mmolO2/m3/day]
    Respiration <- (Mineralisation+Excretion+DINuptake*RespFrac)*ONratio
    GrossPhotosynthesis <- DINuptake*ONratio
#Net Oxygen production
    NetO2Prod <-GrossPhotosynthesis-Respiration
    
# Atmospheric air-sea exchange   
Piston         <- gas_transfer(t = Temperature, u10 = Wind, species = "O2")*86400  # m/d

#Compute the saturation constant of oxygen
Satox          <- gas_O2sat(S = Salinity, t = Temperature) / molweight("O2") #in mol/m3
   
#convert from mol/m3 in mmol/m3
Satox<-Satox*1000  

#if the water is undersaturated (i.e. Satox>DOX) (resp. over, ie. Satox<DOX) then the AirSeaExchange will be positive (resp. negative), water will gain (resp. loose) oxygen.    
 
AirSeaExchange <- Piston*(Satox - DOX)   # mmol O2 / m2 / d, 

#Percentage of Saturation
DOXSat<-DOX/Satox*100

# Sign of saturation
OxDIFF<-Satox - DOX

#Mimic Eutrophication: add river inputs of DIN and DET
RiverDIN<-DilRate*DIN_River
RiverDET<-DilRate*DET_River

  #=======================================!
# The rate of change of state variables !
#=======================================!
# Mass balances [mmolN/m3/day]

## CASE: Wihtout lateral transport

   dDIN      <- Mineralisation + Excretion - DINuptake 
   dPHYTO    <- DINuptake - Grazing -MortalityPHYTO
   dZOO      <- ZooGrowth - Excretion - MortalityZOO
   dDET      <- MortalityZOO +MortalityPHYTO - Mineralisation + Faeces  
   
## CASE: EUTROPHICATION With lateral transport and rivers
   
  #dDIN      <- Mineralisation + Excretion - DINuptake +RiverDIN -DilRate*DIN
  #dPHYTO    <- DINuptake - Grazing -MortalityPHYTO - DilRate*PHYTO
  #dZOO      <- ZooGrowth - Excretion - MortalityZOO-DilRate*ZOO
  #dDET      <- MortalityZOO +MortalityPHYTO- Mineralisation + Faeces +RiverDET -DilRate*DET

## Oxygen balances [mmolO2/m3/day]

#CASE: SURFACE
dDOX  <-NetO2Prod + AirSeaExchange/depth   

#CASE: UNDERWATER
#dDOX  <-NetO2Prod

# Total nitrogen in the system in mmolN/m3
TotalN <- DIN+PHYTO+ZOO+DET 
    
#Chlorophyll in mgChla/m3    
Chlorophyll<-PHYTO*ChlNratio  
    
# # The model function must first return the rates of the state variables 
# (in the order in which they are defined) -  then the ordinary variables are returned
    return (list(c(dDIN, dPHYTO, dZOO, dDET,dDOX),   # the rates of change
                   TotalN = TotalN, Chlorophyll=Chlorophyll, # ordinary output variables
                   AirSeaExchange = AirSeaExchange, 
                   Satox=Satox, 
                 OxDIFF=OxDIFF,
                 DOXSat=DOXSat,
                   Temperature = Temperature,
                   Wind = Wind,
                   PAR = PAR,
                   DINuptake=DINuptake,
                   Grazing=Grazing,
                   Excretion=Excretion,
                   ZooGrowth=ZooGrowth,
                   MortalityPHYTO=MortalityPHYTO,
                 MortalityZOO=MortalityZOO,
                   Mineralisation=Mineralisation,
                   Faeces=Faeces,
                 GrossPhotosynthesis=GrossPhotosynthesis,
                 Respiration=Respiration,
                 NetO2Prod=NetO2Prod)                  
           )
    })
  }  # end of model equations

```

# Model run
## Time
To run the model, we need to first define the time steps at which we want to resolve the model. 


```{r}
NYEARS <- 1. # number of years of integration
dt     <- 1. # time step
times  <- seq(from = 0, to = NYEARS*365, by = dt)

```

## Solving the model

We run the model two times for one years, but keep only the output of the second year. The initial conditions of the second year is taken to be the final condition of the first year simulation.

Function *ode* from the *deSolve* package is used to solve the model. Here the time derivatives of the state variables (that make up the model) is integrated so as to obtain the concentrations. Note that, due to the complexity of the model, this takes a lot of time - be patient.

```{r}
  P    <- ode   (y        = States,
                 times    = times,
                 func     = NPZDO2,
                 parms    = Parms )
```

## Plotting output variables and state variables
#The model solution is a matrix with values of the state variables and the output variables, at each time step.
#We can select *which* variables we want to be displayed and how the figures have to be arranged (*mfrow = c(4, 3)* means 4 rows and 3 columns)

```{r}
# This chunk is to prepare the data to use ggplot2. Using ggplot 2 requres the data to be in the form of a data framew.

library(tidyr)
# Converting the model data (P) into a data frame
P_df <- as.data.frame(P)
# Adding the time column to data
P_df$time <- times  
# Reshaping the data into a "long" format for ggplot2
P_long <- pivot_longer(
    P_df,
    cols = -time,  # this is to use all columns except 'time'
    names_to = "Variable",  # Name the column for parameters
    values_to = "Value"     # Name the column for values
)
```

```{r}
# This is just to check if the transformation to data frame to use ggplot2 did not alter the original dataset

all.equal(P[, "DOXSat.O2"], subset(P_long, Variable == "DOXSat.O2")$Value)

head(P[, "DOXSat.O2"])  

```
```{r, fig.width = 3.5, fig.height=3.5}
# While using ggplot2; I was facing an issue where the command "facetwrap" organizes the plots in the small-multiple format but it does not label the x-axis for each subplot. So to have a plot with a labelled x axis, I individually plot the variables I need in the report to make my argument. 

#Subset data for one variable (e.g., "PHYTO")
single_variable_data <- subset(P_long, Variable == "TotalN")
library(ggplot2)
# Creating the plot
ggplot(single_variable_data, aes(x = time, y = Value)) +
  geom_line(color = "#FF00F5", size = 1) +  
  labs(
    title = "TotalN",
    x = "Time (days)",
    y = "Value"
  ) +
  # scale_y_continuous(limits = c(3.075, 3.1)) + (UNCOMMENT FOR TOTAL N TO FIX SCALE)
  theme_minimal() +  
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.major = element_line(color = "gray90"),
    panel.background = element_rect(fill = "white")
  )

```


```{r, fig.width = 10, fig.height=9}
par(mfrow=c(4,3))
# This chunk is to plot with ggplot2:

ggplot(P_long, aes(x = time, y = Value)) +
    geom_line(aes(color = Variable)) +
    facet_wrap(~Variable, scales = "free_y", ncol = 5) +  
    scale_color_manual(values = rainbow(length(unique(P_long$Variable)))) +  
    ggtitle("Model Parameters v/s Time") +  
    xlab("Time (days)") +  
    ylab("Value") +  
    theme(
        strip.text = element_text(size = 10),  
        axis.text.x = element_text(angle = 90, hjust = 1),  
        panel.grid.major = element_line(color = "gray90"),  
        panel.background = element_rect(fill = "white"),  
        legend.position = "none" 
    )
```
```{r}
# This is just to maintain homogenity. I use the same hex codes for the individual subplots in the previous chunk; copy paste the relevant hex code based on the color used in the main plot to generate subplots.

num_variables <- length(unique(P_long$Variable))  # Number of unique variables
variable_colors <- rainbow(num_variables)        # Generate the rainbow palette

print(variable_colors)

```

```{r, fig.width = 8, fig.height=10}
# This was part of the original code to plot the variables using the standard R graphics...

#plot(P, mfrow = c(4, 3), which = 1:12)
#plot(P, mfrow = c(4, 3), which = 12:(ncol(P)-1))
```

## Comparison with Observations

```{r, fig.width = 7, fig.height=3}

# converting into a single data frame
oxygen_data <- data.frame(
  Time = c(times, data.oxygen[, 2]),
  Oxygen = c(P[, 6], 1000 * data.oxygen[, 3]),
  Type = c(rep("model", length(times)), rep("data", nrow(data.oxygen)))
)

ggplot(oxygen_data, aes(x = Time, y = Oxygen, color = Type)) +
  geom_line(data = subset(oxygen_data, Type == "model"), size = 0.75, ) +
  geom_point(data = subset(oxygen_data, Type == "data"), size = 0.5, ) +
  labs(
    title = "Oxygen in mmol O2/m3",
    x = "Days",
    y = "Oxygen, mmol O2/m3"
  ) +
  scale_color_manual(values=c("model"="black", "data"="red")) +
  scale_y_continuous(limits = c(200, 280)) +
  theme_minimal() + 
  theme(legend.position = "right",  
        legend.title = element_text(size = 12, face = "bold"),  
        legend.text = element_text(size = 10),
        panel.border = element_rect(color = "black", fill = NA, size = 1)
        )   
```

```{r}
## This is my code to understand the sensitivity of the two selected parameters (maxUptake and maxGrazing)

# Define parameter ranges
maxGrazing_values <- seq(0.5, 2.5, by = 0.5)  # Vary maxGrazing from 0.5 to 2.5
maxUptake_values <- seq(0.25, 1.0, by = 0.25)   # Vary maxUptake from 1.0 to 3.0

# Store results
results_grazing <- list()
results_uptake <- list()

# Loop over maxGrazing values
for (g in maxGrazing_values) {
    Parms["maxGrazing"] <- g
    P <- ode(y = States, times = times, func = NPZDO2, parms = Parms)
    results_grazing[[paste0("maxGrazing_", g)]] <- P
}

# Loop over maxUptake values
for (u in maxUptake_values) {
    Parms["maxUptake"] <- u
    P <- ode(y = States, times = times, func = NPZDO2, parms = Parms)
    results_uptake[[paste0("maxUptake_", u)]] <- P
}

# Extract PHYTO from results
sensitivity_data_grazing <- data.frame(
    Time = rep(times, length(maxGrazing_values)),
    PHYTO = unlist(lapply(results_grazing, function(res) res[, "PHYTO"])),
    maxGrazing = rep(maxGrazing_values, each = length(times))
)

# Extract PHYTO for maxUptake variations
sensitivity_data_uptake <- data.frame(
    Time = rep(times, length(maxUptake_values)),  # Replicate time for all runs
    PHYTO = unlist(lapply(results_uptake, function(res) res[, "PHYTO"])),  # Extract PHYTO values
    maxUptake = rep(maxUptake_values, each = length(times))  # Replicate maxUptake values
)

# Plot PHYTO sensitivity to maxUptake
ggplot(sensitivity_data_uptake, aes(x = Time, y = PHYTO, color = factor(maxUptake))) +
    geom_line() +
    labs(title = "Sensitivity of PHYTO to maxUptake",
         x = "Time", y = "Phytoplankton Biomass",
         color = "maxUptake")

# Plot PHYTO sensitivity to maxGrazing
library(ggplot2)
ggplot(sensitivity_data_grazing, aes(x = Time, y = PHYTO, color = factor(maxGrazing))) +
    geom_line() +
    labs(title = "Sensitivity of PHYTO to maxGrazing",
         x = "Time", y = "Phytoplankton Biomass",
         color = "maxGrazing")
```



# Sensitivity Analysis (bonus exercise involving FME package)
## 1. Parameters Selection
Select the parameters that you want to perturb among the parameter list, Define a dataframe with the perturbed parameters. First, we choose all the paramters in order to identify the most sensitive ones. Then, we will concentrate on the most sensitive ones. 

```{r}
pselect<- c("maxUptake","ksPAR","ksDIN","kd","RespFrac","maxGrazing","ksGrazing","pFaeces","excretionRate","mortalityRateZOO","mortalityRatePHYTO","mineralisationRate","TempTrend")
parRanges <- data.frame(min = Parms[pselect]*0.5, max = Parms[pselect]*1.5)
rownames(parRanges) <- names(Parms[pselect])
parRanges
```
## 2. Sensitivity function 
define a function that will run the model with modified paramters, is called by the sensitivity routine and output model variables

```{r}

outtimes  <- seq(from = 0, to = 365, by = dt)
SensitivityNPZDO2 <-function(Parms, outtimes) {
  
P    <- ode   (y= States,
                 times    = times,
                 func     = NPZDO2,
                 parms    = Parms )
        return(as.data.frame(P)) 
}

#out<-SensitivityNPZDO2(Parms)
```


## 3. Local Sensitivity (bonus exercise involving FME package)
Estimate Local Sensitivity in order to rank the parameters by their influence on model results
```{r}
LocalSens<-sensFun(func = SensitivityNPZDO2, parms = Parms, sensvar=c("DIN","PHYTO","ZOO","DET","DOX"), senspar = pselect, varscale = NULL)
head(LocalSens)
plot(LocalSens)
summary(LocalSens)
#Compute the Sensitivity for each state variable
summary(LocalSens,var=TRUE)

```

## 4. Global Sensitivity (bonus exercise involving FME package)

```{r}
Sens<-sensRange(func = SensitivityNPZDO2, parms = Parms, dist = "unif", 
parRange =parRanges, sensvar=c("DIN","PHYTO","ZOO","DET","DOX"),num=30) 
GlobalSens<-summary(Sens)
plot(GlobalSens, which = c("DIN", "PHYTO", "ZOO", "DET","DOX"), xyswap = FALSE, legpos = "topright")
head (GlobalSens)
mtext(side = 3, line = -1, outer = TRUE, "Sensitivity  ", cex = 1.15)
```


# References
Package to solve the differential equations

Karline Soetaert, Thomas Petzoldt, R. Woodrow Setzer (2010). Solving Differential Equations in
  R: Package deSolve. Journal of Statistical Software, 33(9), 1--25. URL
  http://www.jstatsoft.org/v33/i09/ DOI 10.18637/jss.v033.i09.

Package to estimate the oxygen saturation

Karline Soetaert, and Thomas Petzoldt (2017). marelac: Tools for Aquatic Sciences.
  R package version 2.1.6  
  